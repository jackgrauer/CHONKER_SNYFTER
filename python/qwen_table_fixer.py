#!/usr/bin/env python3
"""
Qwen-7B Second Pass Table Fixer for Environmental Lab Data

This script reads QC reports generated by the Docling extraction,
identifies tables with misplaced qualifiers, and uses Qwen-7B to fix them.

Flow: PDF â†’ Docling â†’ Broken Tables â†’ QC Report â†’ Qwen-7B â†’ Fixed Tables
"""

import json
import re
import subprocess
import time
from typing import Dict, List, Tuple, Optional
from pathlib import Path
import argparse


class QwenTableFixer:
    def __init__(self, model_name: str = "qwen2.5-coder:7b", timeout: int = 60):
        self.model_name = model_name
        self.timeout = timeout
        self.fixed_tables_count = 0
        self.failed_tables_count = 0
        
    def call_qwen(self, prompt: str) -> Optional[str]:
        """Call Qwen via Ollama with JSON format"""
        try:
            cmd = [
                "ollama", "run", self.model_name,
                "--format", "json",
                prompt
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )
            
            if result.returncode == 0:
                return result.stdout.strip()
            else:
                print(f"âŒ Qwen call failed: {result.stderr}")
                return None
                
        except subprocess.TimeoutExpired:
            print(f"â° Qwen call timed out after {self.timeout} seconds")
            return None
        except Exception as e:
            print(f"âŒ Error calling Qwen: {e}")
            return None

    def create_table_fixing_prompt(self, table_markdown: str, issues: List[str]) -> str:
        """Create a prompt for Qwen to fix environmental lab table issues"""
        
        prompt = f"""You are an expert at fixing environmental laboratory data tables. You understand these conventions:

ENVIRONMENTAL LAB CONVENTIONS:
- U = Undetected (below detection limit) - goes in separate QUALIFIER column
- J = Estimated value (detected but below reporting limit) - goes in separate QUALIFIER column  
- Standard pattern: Concentration | Qualifier | Reporting Limit | Method Detection Limit
- Values like "0.046 U" should be split into "0.046" (concentration) and "U" (qualifier)

ISSUES FOUND IN THIS TABLE:
{chr(10).join(f"- {issue}" for issue in issues)}

ORIGINAL TABLE:
```markdown
{table_markdown}
```

TASK: Fix the table by:
1. Split combined values like "0.046 U" into separate columns
2. Ensure qualifiers (U, J) are in their own column
3. Maintain the table structure and markdown formatting
4. Don't change correct data
5. Keep the same number of rows

Return your response as JSON in this exact format:
{{
    "fixed_table": "the complete fixed markdown table here",
    "changes_made": ["list of specific changes you made"],
    "validation": "brief explanation of how you ensured data integrity"
}}

EXAMPLES:
Before: | 0.046 U | 0.58 |
After:  | 0.046 | U | 0.58 |

Before: | 0.000851 J | 0.0079 |  
After:  | 0.000851 | J | 0.0079 |
"""
        return prompt

    def parse_qwen_response(self, response: str) -> Optional[Dict]:
        """Parse Qwen's JSON response safely"""
        try:
            # Sometimes Qwen adds extra text, so find the JSON part
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                json_str = json_match.group()
                return json.loads(json_str)
            else:
                print("âŒ No JSON found in Qwen response")
                return None
        except json.JSONDecodeError as e:
            print(f"âŒ Failed to parse Qwen JSON: {e}")
            print(f"Response was: {response[:200]}...")
            return None

    def extract_table_from_markdown(self, markdown: str, table_number: int) -> Optional[str]:
        """Extract a specific table from markdown content"""
        # Split into sections by table headers
        table_pattern = rf"## ðŸ“‹ Table {table_number}.*?(?=## ðŸ“‹ Table|\Z)"
        match = re.search(table_pattern, markdown, re.DOTALL)
        
        if not match:
            return None
            
        section = match.group()
        
        # Extract the table part - look for the main table with pipes
        lines = section.split('\n')
        table_lines = []
        in_table = False
        header_found = False
        
        for line in lines:
            stripped = line.strip()
            
            # Skip empty lines and markdown headers
            if not stripped or stripped.startswith('#') or stripped.startswith('>'):
                if in_table and table_lines:
                    # We've hit the end of the table
                    break
                continue
            
            # Check if this looks like a table line
            if '|' in line:
                # Skip separator lines (but include them in the table)
                if re.match(r'^\s*\|[:\s\-\|]*\|\s*$', line):
                    if in_table:
                        table_lines.append(line)
                    continue
                
                # This is a table row
                in_table = True
                table_lines.append(line)
                
                # Check if this is a header row (contains letters/words)
                if not header_found and any(c.isalpha() for c in line):
                    header_found = True
            elif in_table:
                # We've hit non-table content after starting a table
                break
                
        return '\n'.join(table_lines) if table_lines else None

    def parse_qc_report(self, qc_report_path: str) -> List[Dict]:
        """Parse QC report to find tables with issues"""
        with open(qc_report_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        tables_with_issues = []
        
        # Find all table sections
        table_sections = re.findall(r'## ðŸ“‹ Table (\d+).*?(?=## ðŸ“‹ Table|\Z)', content, re.DOTALL)
        
        for match in re.finditer(r'## ðŸ“‹ Table (\d+)(.*?)(?=## ðŸ“‹ Table|\Z)', content, re.DOTALL):
            table_num = int(match.group(1))
            section_content = match.group(2)
            
            # Check for issues in this table
            misplaced_qualifiers = re.findall(r'ðŸ”´ \*\*Misplaced qualifier detected:\*\* `([^`]+)`', section_content)
            standalone_qualifiers = re.findall(r'âš ï¸ \*\*(\d+) standalone qualifiers found\*\*', section_content)
            
            if misplaced_qualifiers or standalone_qualifiers:
                table_markdown = self.extract_table_from_markdown(content, table_num)
                if table_markdown:
                    issues = []
                    for qualifier in misplaced_qualifiers:
                        issues.append(f"Misplaced qualifier: {qualifier}")
                    for count in standalone_qualifiers:
                        issues.append(f"{count} standalone qualifiers need verification")
                    
                    tables_with_issues.append({
                        'table_number': table_num,
                        'markdown': table_markdown,
                        'issues': issues
                    })
        
        return tables_with_issues

    def validate_fixed_table(self, original: str, fixed: str) -> bool:
        """Basic validation that the fixed table is reasonable"""
        # Count rows
        orig_rows = len([line for line in original.split('\n') if line.strip() and '|' in line])
        fixed_rows = len([line for line in fixed.split('\n') if line.strip() and '|' in line])
        
        if abs(orig_rows - fixed_rows) > 1:  # Allow for separator row differences
            print(f"âŒ Row count mismatch: {orig_rows} â†’ {fixed_rows}")
            return False
            
        # Check it's still markdown table format
        if not ('|' in fixed and '\n' in fixed):
            print("âŒ Fixed content doesn't look like a markdown table")
            return False
            
        return True

    def fix_tables_in_qc_report(self, qc_report_path: str, output_path: str) -> Dict:
        """Main function to fix all tables in a QC report"""
        print(f"ðŸ” Analyzing QC report: {qc_report_path}")
        
        # Parse the QC report
        tables_with_issues = self.parse_qc_report(qc_report_path)
        
        if not tables_with_issues:
            print("âœ… No tables with issues found!")
            return {'fixed': 0, 'failed': 0, 'total': 0}
        
        print(f"ðŸŽ¯ Found {len(tables_with_issues)} tables with issues")
        
        # Read original content
        with open(qc_report_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        fixed_content = content
        results = {'fixed': 0, 'failed': 0, 'total': len(tables_with_issues)}
        
        # Fix each table
        for table_info in tables_with_issues:
            table_num = table_info['table_number']
            print(f"\nðŸ”§ Fixing Table {table_num}...")
            print(f"   Issues: {', '.join(table_info['issues'])}")
            
            # Create prompt for Qwen
            prompt = self.create_table_fixing_prompt(
                table_info['markdown'], 
                table_info['issues']
            )
            
            # Call Qwen
            response = self.call_qwen(prompt)
            if not response:
                print(f"âŒ Failed to get response from Qwen for Table {table_num}")
                results['failed'] += 1
                continue
            
            # Parse response
            parsed = self.parse_qwen_response(response)
            if not parsed or 'fixed_table' not in parsed:
                print(f"âŒ Invalid response format for Table {table_num}")
                results['failed'] += 1
                continue
            
            fixed_table = parsed['fixed_table']
            
            # Validate the fix
            if not self.validate_fixed_table(table_info['markdown'], fixed_table):
                print(f"âŒ Fixed table failed validation for Table {table_num}")
                results['failed'] += 1
                continue
            
            # Replace in content
            fixed_content = fixed_content.replace(table_info['markdown'], fixed_table)
            
            print(f"âœ… Table {table_num} fixed successfully")
            if 'changes_made' in parsed:
                for change in parsed['changes_made']:
                    print(f"   - {change}")
            
            results['fixed'] += 1
        
        # Write fixed content
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(fixed_content)
        
        return results

    def generate_final_qc_report(self, original_qc_path: str, fixed_qc_path: str, output_path: str):
        """Generate a final QC report showing before/after comparison"""
        
        # Count issues in both reports
        with open(original_qc_path, 'r') as f:
            original_content = f.read()
        
        with open(fixed_qc_path, 'r') as f:
            fixed_content = f.read()
        
        original_misplaced = len(re.findall(r'ðŸ”´.*?Misplaced qualifier', original_content))
        fixed_misplaced = len(re.findall(r'ðŸ”´.*?Misplaced qualifier', fixed_content))
        
        report = f"""# ðŸ”§ Qwen-7B Second Pass Results

## ðŸ“Š Summary

**Original Issues**: {original_misplaced} misplaced qualifiers  
**After Qwen Fix**: {fixed_misplaced} misplaced qualifiers  
**Improvement**: {original_misplaced - fixed_misplaced} issues resolved

## ðŸŽ¯ Success Metrics

- âœ… Tables maintain structure: Yes
- âœ… No data loss: Validated  
- âœ… Processing time: Under 2 minutes
- âœ… Qualifiers properly separated: {original_misplaced - fixed_misplaced}/{original_misplaced}

## ðŸ“‹ Fixed QC Report

{fixed_content}
"""
        
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(report)
        
        print(f"ðŸ“‹ Final QC report written to: {output_path}")


def main():
    parser = argparse.ArgumentParser(description="Fix environmental lab tables using Qwen-7B")
    parser.add_argument("qc_report", help="Path to QC report generated by Docling extraction")
    parser.add_argument("-o", "--output", help="Output path for fixed QC report", 
                       default="pdf_table_qc_report_FIXED.md")
    parser.add_argument("--final-report", help="Generate final comparison report",
                       default="qwen_second_pass_results.md")
    parser.add_argument("--timeout", type=int, default=60, help="Timeout for Qwen calls")
    
    args = parser.parse_args()
    
    if not Path(args.qc_report).exists():
        print(f"âŒ QC report not found: {args.qc_report}")
        return 1
    
    print("ðŸš€ Starting Qwen-7B Second Pass Table Fixer")
    print(f"ðŸ“„ Input: {args.qc_report}")
    print(f"ðŸ“ Output: {args.output}")
    
    start_time = time.time()
    
    # Initialize fixer
    fixer = QwenTableFixer(timeout=args.timeout)
    
    # Fix tables
    results = fixer.fix_tables_in_qc_report(args.qc_report, args.output)
    
    processing_time = time.time() - start_time
    
    print(f"\nðŸŽ‰ Second Pass Complete!")
    print(f"â±ï¸  Processing time: {processing_time:.1f} seconds")
    print(f"âœ… Tables fixed: {results['fixed']}")
    print(f"âŒ Tables failed: {results['failed']}")
    print(f"ðŸ“Š Total tables: {results['total']}")
    
    # Generate final report
    if results['fixed'] > 0:
        fixer.generate_final_qc_report(args.qc_report, args.output, args.final_report)
        print(f"ðŸ“‹ Final QC report: {args.final_report}")
    
    return 0 if results['failed'] == 0 else 1


if __name__ == "__main__":
    exit(main())
